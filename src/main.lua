#! /usr/bin/lua
-- Rules in .XCompose files are hard to read so I made this script to convert
-- a more readable notation to the official notation

local XCOMPOSER_NAME    = "xcomposer"
local XCOMPOSER_VERSION = '2.0'
local XCOMPOSER_FULL_NAME = XCOMPOSER_NAME .. " " .. XCOMPOSER_VERSION

local ComposeFile = require 'xcomposer.ComposeFile'
local util        = require 'xcomposer.util'

local argparse = require 'argparse'
local cosmo    = require 'cosmo'
local utf8     = require 'dromozoa.utf8'

--
-- Main function
--

local im_module_warning = cosmo.f [[
Composition sequences may not work because the $(envvar) environment
variable is not set. Consider adding the following to your .xsessionrc:
    export $(envvar)="xim"
]]

local ibus_module_warning = cosmo.f [[
Environment variable $(envvar) is set to "ibus" but ibus ignores .XCompose
files. Consider using "xim" or another input module that supports .XCompose
]]

local generated_header = cosmo.f [[
# THIS FILE WAS AUTOMATICALLY GENERATED BY $(progname)
# DO NOT MODIFY IT BY HAND

]]

local function xcomposer(args)
  local infilename = args.input
  local outfilename = args.output

  for _, envvar in ipairs({"GTK_IM_MODULE", "QT_IM_MODULE"}) do
    local value = os.getenv(envvar)
    if not value then
      io.stderr:write( im_module_warning {envvar=envvar} )
      io.stderr:write("\n")
    end
    if value == "ibus" then
      io.stderr:write( ibus_module_warning {envvar=envvar} )
      io.stderr:write("\n")
    end
  end


  local cf = ComposeFile.new()

  local rule = util.supercurry({
    {name='output',      optional=false },
    {name='input',       optional=false },
    {name='compose_key', optional=true, default=true},
  }, function(output, input, compose_key)
    cf:add_rule({
      input = input,
      output = output,
      compose_key = compose_key
    })
  end)

  local _ENV2 = {}
  for k,v in pairs(_ENV) do
    _ENV2[k] = v
  end
  _ENV2.rule = rule
  _ENV2.config = cf.config

  if infilename == nil then
    io.stderr:write("Reading from standard input...\n")
  end

  assert(loadfile(infilename, "t", _ENV2))()


  local outfile
  if outfilename == '-' then
    outfile = io.stdout
  else
    outfile = assert(io.open(outfilename, 'w'))
  end

  outfile:write(generated_header {progname = XCOMPOSER_NAME})
  cf:save_to_file(outfile)
end

--
-- Reading command line parameters
--

local homedir = os.getenv('HOME')
if not homedir then
  io.stderr:write("Could not read $HOME environment variable\n")
  io.exit(1)
end

local function print_version_and_exit()
    print(XCOMPOSER_FULL_NAME)
    os.exit(0)
end


local pp = argparse({
    name = "xcomposer",
    description = "A tool for writing readable XCompose rules",
    epilog = "For more info see https://github.com/hugomg/xcomposer",
})
pp:flag({
    name = "-v --version",
    description = "Show version info and exit",
    action = print_version_and_exit,
})
pp:option({
    name = "-o --output",
    description = "Output file",
    args = 1,
    default = homedir..'/.XCompose',
})
pp:argument({
    name = "input",
    description = "Input file (default: standard input)",
    args = '?'
})

xcomposer(pp:parse())
